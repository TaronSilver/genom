
#-1 Formatting example, how to use the file.

	To do this

Done	* Foo

InProg	* Bar

	* Foobar

Done	* Blubb



Done by: Person1, Person2 
InProg: Person2 

Function names: utility/Foo(), user_interaction/bar()
Gtest: FooTest.cpp, barTest.cpp





STUFF TO DO:
————————————————————————————————————————————————————————————————————————————————
				ABSOLUTELY NECESSARY
————————————————————————————————————————————————————————————————————————————————

#0 Handle the base probabilities

	To do this: 

DONE	* Create a function in user interaction which asks how the user would like
	  to fill the base probabilities. It should return some kind of enum.

DONE	* Create a function in user interaction which asks for the specific base
	  probabilities, if the user wants to do this. 

DONE	* Create a function in utility that handles all this, and that returns a 
	  vector of base probabilities.

DONE	* Add this function at the beginning of each procedure that includes Matrices

DONE	* Put the base probabilities in every constructor of Matrices. 

	The feature in which the base probabilities are calculated based on a 
	sequence isn’t very important at this point, and still quite a pain to 
	implement. I therefore suggest only to do this if we have too much time.

Done by: mattminder
InProg:

Function names: user_interaction/AskBaseProb()
Gtest:


#1 Write a function to save a matrix to a desired file

	To do this:

DONE	* Write a function in user_interaction that asks the user for the 
	  filename of the output matrix
	  Check if there is a format, if not add .mat

DONE	* Write a function in user_interaction that asks the user for the 
	  type of the output matrix, return it as a MATRIX_TYPE

DONE	* Create a public function Matrix::save_matrix(), which uses the two 
	  functions listed above, and saves the matrix to a file. Use the private
	  function 
	  	log_to_matrix(Matrix_Neo input_matrix, MATRIX_TYPE type)
	  with the Class attribute logMatrix and the specified type to create a 
	  converted matrix, and then save this matrix

	  A similar thing has already existed in the previous version, look there
	  for inspiration. It’s also called save_matrix().
	  
	  Note that the name is important in this case to allow for the proper 
	  functioning of other functions

TODO	* If the function to create an image exists, give the user also the choice
	  of saving the matrix as image. 

Done by: mattminder
InProg:

Function names: 
	* Ask for type: Ask_Return_Matrix_Type()
	* Ask for filename: Ask_Outputfile_Name()
	* Save matrix: Matrix::save()
Gtest:


#3 Let the user save a matrix file from the results of the previous analysis of 
binding positions on a sequence. 

	To do this:
	
	* Ask the user in user_interaction if he wants to weigh the results by their
	  score

	* As soon as it has been implemented in #4, ask the user in user_interaction
	  if he wants to convert the score back to a probability score, and weigh the
	  sequences by that.

	* Use the function yet to be implemented in #4 to create a Matrix_Neo with
	  the probabilities of each position.

	* Initialize the Matrix with the constructor
	  which takes a Matrix_Neo, a type (which would be 
	  MATRIX_TYPE::absoluteMatrix) and base probabilities as argument. 

	  As base probabilities, I propose to use the same as we used for the initial
	  conversion, earlier in procedure. This isn’t implemented yet, if it’s 
	  still not done leave this part empty, the constructor will use .25.
	  
	* Use the function yet to be implemented in #1 called 
	  Matrix::save_matrix() to save the matrix to a desired output file. 
	
Done by:
InProg:

Function names:
Gtest:  


#4 Create a function that creates a Matrix_Neo based on sequences of the same length.

	To do this:

DONE	* Write a function that takes a vector of SearchResult as argument and
	  that returns a probability weight matrix based on the sequences in the 		  
	  SequenceResult. 

	  A similar thing was done in the old version, but it loaded it from a file
	  while we now have them stored. But it might inspire you.	

	* Also take a bool as argument which says whether each sequence is weighed by
	  the score

	* Maybe also take a bool as argument which indicates if the score should be 
	  converted back from a log score to a prob score. 

	  Write a function that converts a log score to a prob score. This can be 
	  approximated using the following formula: 

	  s(prob) = exp( s(log) ) * 0.25^n

	  with n being the length of the sequences. This formula approximates that 
	  the base probabilities are all 0.25, otherwise it is not possible to 
	  calculate it without redoing the search. 

	  Then weigh each sequence by the recalculated score. 

	  This feature is however supplementary and has a low importance. If it is
	  implemented, add it to #3. 
  
Done by:
InProg:

Function names:
Gtest:



HANDLING GENOMIC COORDINATES

#10 Create a class for genomic coordinates.

	To do this:

	There are of course several ways this class could be organized. One way 
	would be to create a class of a single set of genomic coordinates, and then 
	to work with a vector of said coordinates. Another would be
	to create a class with each attribute of all genomic coordinates in a file 
	stored as a vector. A third, and probably the neatest way to do it,
	would be to create a class for one set of coordinates and another class with
	all sets of coordinates from a given file. 

	Another question to ask ourselves is whether we want to store the beginning
	and the end position, or the beginning and the length. In the end we’re going
	to work with the length, but 
	
	Disregarding how we’re gone implement the class, we absolutely need the 
	following functions:
	
	* Create a function that reads a file with genomic coordinates (the file name
	  is taken as argument), and saves them in the class / the vector.
	
	* Create a function in user_interaction that asks for the name of a file 
	  with genomic coordinates
	
	* Create a constructor for the class

	* Store the information whether there’s a description in the third column as 
	  a bool, if possible only once.

Done by:
InProg:

Function names:
Gtest:



#11 Create a function that takes the information of genomic coordinates as well as 
the name of a sequence file as argument, and returns an element of SearchResults 
with all sequences that are at the specified positions.

	To do this:
	
	* Figure out if this has to be done only of the forward or also the backward
	  direction. If it also has to be done on the reverse strand create a 
	  function that converts it to the complementary sequence

	* Put the name of the sequence description at the beginning as description

	* Try to optimize this function as much as possible, as large files are 
	  frequent. 

	* Put the score indicated in the genomic coordinates for the current position 
	  as score of the class

	* If there are multiple sequences, print a warning

	* If there are more coordinates than the length of the sequence, print a 
	  warning

	* Ask the user in a separate function in user_intraction at what position 
	  the genomic coordinates / the sequence starts. 

Done by:
InProg:

Function names:
Gtest:




#12 Write a function that will implement the EM-Algorithm. It should take a vector
of SearchResult as argument as well as the length of the output sequence (also maybe 
a delimiting parameter) and return a Matrix_Neo of the resulting probability weight 
matrix. 

	To do this:
	
	* The EM-Algorithm has to be stopped at some point, maybe give the user the 
	  choice for this parameter. I propose that the Algorithm function itself 
	  takes this parameter as argument, and that the user is asked about the 
	  parameter before calling the function.

	  Also maybe it would be nice to give the user several parameters to choose 
	  from, such as time or the difference between two matrices. As soon as one
	  is reached, it is stopped. 

	* Weigh the sequences by their score

	* Since this function does the same things over and over again, try to 
	  modularize it as much as possible into small functions. 

	* If you can think of a way where we don’t have to copy all the sequences
	  to the memory in a vector in order to run the EM-Algorithm without loosing
	  too much time, feel free to implement it.

	* Use the map charmap in utility for the conversion into the type nuc

Done by:
InProg:

Function names:
Gtest:




#13 Create a function that determines which of several probability weight matrix
describes a set of sequences in the best way. Take a vector of probability weight 
matrices (type Matrix_Neo) and a vector of strings with sequences as input and then return the index of the matrix 

	To do this:
	I have no idea, ask the professor. Maybe try to calculate a score, but also
	take into account that the matrices will not have the same amount of 
	positions.

Done by:
InProg:

Function names:
Gtest:




#14 Modification of procedure for creating a matrix from sequences

	I propose the following order:
	
	* Give the user a choice whether he wants to run the analysis based on 
	  several sequences in a sequence file, or based on a sequence and genomic
	  coordinates file

	* Add a while loop that allows the user to analyze several files at the same
	  time. 

	* Determine whether the sequences all have the same length or not, or ask the 
	  user whether this is the case

	* If they are all in fact all the same length, call the function created in 
	  #4, as part of the constructor of a Matrix, and give absoluteMatrix as 
	  type. 

	* If they are not the same length:  

	  Ask the user (in a function in user_interaction) what range of lengths he 
	  wants to have.

	  Ask the user what delimiting parameter he would like to use for the 
	  EM-Algorithm in a function in user_interaction.

	  Run the EM-Algorithm with all the lengths in the user specified lengths,
	  and the given parameters (#12). Save the resulting Matrice_Neos as a 
	  vector.

	  Run the function of #13 with the vector obtained before.

	  Construct a matrix with the Matrix_Neo of the vector with the index 
	  returned of #13. Use absoluteMatrix as type.

	* Call the save_matrix() (#1) on the created Matrix.

Done by:
InProg:

Function names:
Gtest:




#20 Create a function that correlates the score in genomic coordinates with the found results. 

	To do this:

	* Take an instance of SequenceResults as well as an instance of Genomic 
	  coordinates as argument. 

	* Find out what exactly has to be done.

	  I think it was the following: Multiply the score of the found sequence with 
	  the score of the general protein binding affinity at that specific 
	  position, then return a new instance of SequenceResults with the new score. 
	  Add „Correlated with genomic coordinates“ to the description. 

	* Allow the user to manually modify the description, in user interaction.
	  Low priority. 

Done by:
InProg:

Function names:
Gtest:




#21 Create a function that reads an output file with search results into an instance of SearchResults

	To do this:

	* Create a function in user_interaction that asks for the filename.

	* Create a function that takes the filename as argument and returns an 
	  element of search results. 

Done by:
InProg:

Function names:
Gtest:




#30 Modification of procedures: Correlate result

	To do this:

	* Modify the enum PROCEDURE with the new procedure name

	* Modify whatToDo() to give the user the possibility of the new procedure.

	* Create a procedure function that does the following: 

	  Use #10 to read genomic coordinates

	  Use #21, or a combination of #10 with a different genomic coordinate file
	  and #11 with a sequence file to obtain an instance of SearchResults.

	  Ask the user which option he wants to do.

	  Use the function of #20 with the genomic coordinates and the SearchResults 
	  created before. 

Done by:
InProg:

Function names:
Gtest:





————————————————————————————————————————————————————————————————————————————————
				ADDITIONAL FEATURES
————————————————————————————————————————————————————————————————————————————————

#100 Do several graphical representation of the results we obtained.

Done by:
InProg:

Function names:
Gtest:



#101 If there is a - in the sequence, this means a gap of undetermined length. Modify
sequence_analysis such that the lists are restarted if a - occurs.

Done by:
InProg:

Function names:
Gtest:



#102 Treat other base characters such as R (for purin) properly. For the probability 
of these characters, add together the probability of the normal nucleotides. Modify the logMatrix to also contain these characters. Fill them automatically. Then if such a character is found in the sequence, treat it as normal. 

Also modify the EM-Algorithm to include these characters. Just weigh them appropriately. (For instance, if there is a B, add 1/3 of the score to all bases)
https://en.wikipedia.org/wiki/FASTA_format

Done by:
InProg:

Function names:
Gtest:



#103 Create a progress bar

Done by:
InProg:

Function names:
Gtest:



#104 Optimize

Done by:
InProg:

Function names:
Gtest:
